//
//  APIMethodCall.swift
//  APIMethodCall
//
//  Created by Stephen Kockentiedt on 16.09.21.
//

import Foundation
import Vapor

/// An ID used by the code generated by SwiftyBridges to identify an API method
public struct APIMethodID: Codable, Hashable {
    var rawValue: String
}

extension APIMethodID: ExpressibleByStringLiteral {
    public init(stringLiteral value: String) {
        rawValue = value
    }
}

/// A protocl used by structs generated by SwiftyBridges holding the info of an API method call
public protocol APIMethodCall: Content {
    associatedtype API: APIDefinition
    associatedtype ReturnType: Codable
    static var methodID: APIMethodID { get }
    
    /// Executes the method call on the API definition
    /// - Returns: A future for the return value of the API method
    func call(on api: API) throws -> EventLoopFuture<ReturnType>
}

/// This is used as a replacement for the `Void` return type in generated code to prevent compiler errors because `Void` does not conform to `Codable`
public struct NoReturnValue: Codable {
    public init() {}
    public init(from decoder: Decoder) throws {}
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(0)
    }
}

/// This type wraps types conforming to `APIMethodCall` so that calling code can decode API call requests and apply the API call iteself without knowing the return type at compile time
public struct AnyAPIMethod<API: APIDefinition> {
    /// A function type that takes an instance of an API definition, calls an API method with the parameters decoded from the request and encodes the return value as a `Response`
    typealias MethodCall = (API) throws -> EventLoopFuture<Response>
    
    /// The ID used to identify this specific API method
    let methodID: APIMethodID
    
    /// A closure that decodes the method parameters from the request and returns a preconfigured `MethodCall`
    private let decodeCallAction: (Request) -> EventLoopFuture<MethodCall>
    
    /// Creates an instance with a specific type conforming to `APIMethodCall
    /// - Parameters:
    ///   - method: The request that was received for the API method call
    public init<MethodCallType: APIMethodCall>(method: MethodCallType.Type) where MethodCallType.API == API {
        methodID = method.methodID
        decodeCallAction = { (request: Request) -> EventLoopFuture<MethodCall> in
            return MethodCallType.decodeRequest(request).map { (call: MethodCallType) -> MethodCall in
                func callAPIMethodAndEncodeReturnValue(api: API) throws -> EventLoopFuture<Response> {
                    try call.call(on: api).flatMap { $0.encodeResponse(for: request) }
                }
                
                return callAPIMethodAndEncodeReturnValue(api:)
            }
        }
    }
    
    /// Decodes the parameters from the given request and returns a preconfigured method call
    /// - Parameter request: A request encoding an API method call
    /// - Returns: A closure that takes an instance of an API definition, calls the API method represented by this instance with the parameters decoded from `request` and encodes the return value as a `Response`
    func decodeCall(from request: Request) -> EventLoopFuture<MethodCall> {
        decodeCallAction(request)
    }
}

private extension Encodable {
    /// Encodes `Encodable` as  a `Response`.
    ///
    /// - Parameter request: The request for this response
    /// - Returns: A future for the encoded response
    func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
        EncodingHelper(self).encodeResponse(for: request)
    }
}

/// Allows `Encodable` values to be encoded as a `Response`
private struct EncodingHelper<Wrapped: Encodable>: Content {
    var wrappedValue: Wrapped
    
    init(_ wrappedValue: Wrapped) {
        self.wrappedValue = wrappedValue
    }
    
    init(from decoder: Decoder) throws {
        fatalError("EncodingHelper does not support decoding.")
    }
    
    func encode(to encoder: Encoder) throws {
        try wrappedValue.encode(to: encoder)
    }
}
